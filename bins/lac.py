#!/usr/bin/env python3
from lapp.lappfile import parse_lapp
from setuptools._distutils.ccompiler import new_compiler
import argparse
import os
import tempfile
CTEMPLATE=\
'''//THIS CODE WAS AUTO GENERATED BY LAPP COMPILER.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define ERROR_TEMPLATE "LAPP ERR -> %s: %d\\n"

int error(int msg,char *errcode,int returncode){
	fprintf(stderr,ERROR_TEMPLATE,errcode,msg);
	return returncode;
}
int apply_mem_change(int memo,int mem_change,int co,int orig){
	if(mem_change == 3){
		if(co==0){
			return orig;
		}
		return co;
	}
	else if(mem_change==2){
		return memo-1;
	}
	else if(mem_change==1){
		return memo+1;
	}
	else{
		return memo;
	}
}
int main(int argc,char **argv){
	int instr[]={INSTRUCTIONS HERE};
	int instr_c=INSTRUCTION COUNT HERE;
	int memo[16]={0};
    int original_memo[16]={0};
	int start_instr=0;
	for(int i=1;i<argc;i++){
		char *q=argv[i];
		memo[i-1]=atoi(q);
		original_memo[i-1]=atoi(q);
	}
    	while (start_instr<15){

        
		if(start_instr>=instr_c){
			return error(start_instr,"ERRCODE_NO_INSTR",0xbb);
		}
		
		int memo_cell=instr[start_instr*6];
		int target=instr[start_instr*6+1];
		int mem_change=instr[start_instr*6+2];
		int cmp_mode=instr[start_instr*6+3];
		int else_jump=instr[start_instr*6+4];
		int cmp_const=instr[start_instr*6+5];
		if(memo_cell>15){
			return error(memo_cell,"ERRCODE_MEM_INDEX",0x10);
		}

		memo[memo_cell]=apply_mem_change(memo[memo_cell],mem_change,cmp_const,original_memo[memo_cell]);
		if(memo[memo_cell]>65535){
			return error(memo_cell,"ERRCODE_MEM_OVERFLOW",0x20);
		}
		int memo_contents=memo[memo_cell];
		if ((cmp_mode == 0)||(cmp_mode==1 && memo_contents == cmp_const)||(cmp_mode==2 && memo_contents < cmp_const)||(cmp_mode==3 && memo_contents > cmp_const)){
			start_instr=target;
		}
		else{
			start_instr=else_jump;
		}
	        	

	}
    printf("%d\\n",memo[15]);
	return 0;
}
''' # can't use string formatting LOLOLOLOL
def mk_array(lapp):
    arr=[]
    for instr in lapp.instr:
        arr.extend([instr.memory_cell,instr.jump_target,instr.mem_change,instr.cmp_mode,instr.jump_else,instr.cmp_const])
    return arr
def mk_c_code(l,outfile="lapp_program"):
    lapp=parse_lapp(l,[])
    print("Getting instructions.")
    instr_arr=mk_array(lapp)
    cfile=tempfile.mktemp(prefix="cc-",suffix=".c")
    memo_arr=lapp.mem
    if set(memo_arr)not in ({0},set()):
        print("WARN: Default memory is not yet supported with lac. Memory will be set to 0. If you want to keep initial memory ,use lain instead.")
    if lapp.seq:
        print("WARN: Sequential programs are deprecated. Lac will parse the following profram as if it was not sequential.")
    print("Writing C code...")
    c=CTEMPLATE.replace("INSTRUCTIONS HERE",','.join(str(i) for i in instr_arr)).replace("INSTRUCTION COUNT HERE",str(len(instr_arr)//6))
    with open(cfile,"w") as f:
        f.write(c)
    print(f"C code written to {cfile!r}.")
    print("Compiling...")
    comp=new_compiler()
    out=comp.compile([cfile],tempfile.gettempdir())
    print(f"AST stored at {out[0]!r}")
    print("Linking...")
    comp.link_executable(out,outfile)
    print(f"Removing {out[0]!r} and {cfile!r}.")
    os.remove(out[0])
    os.remove(cfile)
    print("Done!")
if __name__=="__main__":
    parser=argparse.ArgumentParser(prog="lac")
    parser.add_argument("infile",nargs=1)
    parser.add_argument("outfile",nargs=1)
    args=parser.parse_args()
    mk_c_code(args.infile[0],args.outfile[0])
